// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map                   = require("bs-platform/lib/js/map.js");
var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Lexing                  = require("bs-platform/lib/js/lexing.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var NANDlexer               = require("./nANDlexer.js");
var NANDparser              = require("./nANDparser.js");
var PL_functor              = require("./pL_functor.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function parseStr(s) {
  return NANDparser.parseProg(NANDlexer.token, Lexing.from_string(s));
}

function genLine(id, l, r) {
  var s = PL_functor.strOfId(id) + (" := " + (l + (" NAND " + (r + "\n"))));
  return NANDparser.parseProg(NANDlexer.token, Lexing.from_string(s));
}

var cell = [0];

function freshVar() {
  var match_000 = /* Int */[cell[0]];
  var match_001 = (cell[0] = cell[0] + 1 | 0, /* () */0);
  return /* tuple */[
          "unique",
          match_000
        ];
}

function isValue(e) {
  switch (e.tag | 0) {
    case 0 : 
    case 1 : 
        return /* true */1;
    case 2 : 
    case 3 : 
        return /* false */0;
    
  }
}

function mapToProg(macro, p) {
  return List.concat(List.map(macro, p));
}

function enableNestedApp(m, p) {
  var p$prime = Curry._1(m, p);
  var enterNestedProgs = function (c) {
    switch (c.tag | 0) {
      case 1 : 
          return /* If */Block.__(1, [
                    c[0],
                    enableNestedApp(m, c[1])
                  ]);
      case 2 : 
          var f = c[1];
          return /* FxnDef */Block.__(2, [
                    c[0],
                    /* record */[
                      /* inputs */f[/* inputs */0],
                      /* outputs */f[/* outputs */1],
                      /* body */enableNestedApp(m, f[/* body */2])
                    ]
                  ]);
      default:
        return c;
    }
  };
  return List.map(enterNestedProgs, p$prime);
}

function SSFromBackEnd(Lang) {
  var addStdLib = function (p) {
    return Pervasives.$at(NANDparser.parseProg(NANDlexer.token, Lexing.from_string("one := zero NAND zero \n     def a := NOT(b) { \n       a := b NAND b \n     }\n     def a := AND(b, c) { \n       a := NOT(b NAND c) \n     }")), p);
  };
  var unzipCom = function (c) {
    var pair = function (v, e) {
      return /* Asg */Block.__(0, [
                /* :: */[
                  v,
                  /* [] */0
                ],
                /* :: */[
                  e,
                  /* [] */0
                ]
              ]);
    };
    if (c.tag) {
      return /* :: */[
              c,
              /* [] */0
            ];
    } else {
      var exps = c[1];
      var _vars = c[0];
      if (exps && exps[0].tag === 3 && !exps[1]) {
        return /* :: */[
                c,
                /* [] */0
              ];
      } else {
        return List.map2(pair, _vars, exps);
      }
    }
  };
  var unzipProg = function (p) {
    return List.concat(List.map(unzipCom, p));
  };
  var expandExp = function (e) {
    if (isValue(e)) {
      return /* tuple */[
              /* [] */0,
              e
            ];
    } else {
      switch (e.tag | 0) {
        case 0 : 
        case 1 : 
            return /* tuple */[
                    /* [] */0,
                    e
                  ];
        case 2 : 
            var v = freshVar(/* () */0);
            var match_000 = expandExp(e[1]);
            var match_001 = expandExp(e[2]);
            var match = match_001;
            var match$1 = match_000;
            return /* tuple */[
                    Pervasives.$at(match$1[0], Pervasives.$at(match[0], /* :: */[
                              /* Asg */Block.__(0, [
                                  /* :: */[
                                    v,
                                    /* [] */0
                                  ],
                                  /* :: */[
                                    /* Binop */Block.__(2, [
                                        e[0],
                                        match$1[1],
                                        match[1]
                                      ]),
                                    /* [] */0
                                  ]
                                ]),
                              /* [] */0
                            ])),
                    /* Var */Block.__(1, [v])
                  ];
        case 3 : 
            var argList = List.map(expandExp, e[1]);
            var processArg = function (param, param$1) {
              return /* tuple */[
                      Pervasives.$at(param[0], param$1[0]),
                      /* :: */[
                        param[1],
                        param$1[1]
                      ]
                    ];
            };
            var match$2 = List.fold_right(processArg, argList, /* tuple */[
                  /* [] */0,
                  /* [] */0
                ]);
            var v$1 = freshVar(/* () */0);
            return /* tuple */[
                    Pervasives.$at(match$2[0], /* :: */[
                          /* Asg */Block.__(0, [
                              /* :: */[
                                v$1,
                                /* [] */0
                              ],
                              /* :: */[
                                /* FxnApp */Block.__(3, [
                                    e[0],
                                    match$2[1]
                                  ]),
                                /* [] */0
                              ]
                            ]),
                          /* [] */0
                        ]),
                    /* Var */Block.__(1, [v$1])
                  ];
        
      }
    }
  };
  var enableAsgCom = function (c) {
    if (c.tag) {
      return /* :: */[
              c,
              /* [] */0
            ];
    } else {
      var match = c[0];
      if (match) {
        if (match[1]) {
          return /* :: */[
                  c,
                  /* [] */0
                ];
        } else {
          var match$1 = c[1];
          if (match$1) {
            if (match$1[1]) {
              return /* :: */[
                      c,
                      /* [] */0
                    ];
            } else {
              var e = match$1[0];
              var u = match[0];
              if (isValue(e) && !Lang[/* supportsAsg */4]) {
                var match_000 = freshVar(/* () */0);
                var match_001 = PL_functor.strOfExp(e);
                var eStr = match_001;
                var newVar = match_000;
                var newVarStr = PL_functor.strOfId(newVar);
                return Pervasives.$at(genLine(newVar, eStr, eStr), genLine(u, newVarStr, newVarStr));
              } else {
                switch (e.tag | 0) {
                  case 2 : 
                      var match_000$1 = expandExp(e[1]);
                      var match_001$1 = expandExp(e[2]);
                      var match$2 = match_001$1;
                      var match$3 = match_000$1;
                      return Pervasives.$at(match$3[0], Pervasives.$at(match$2[0], /* :: */[
                                      /* Asg */Block.__(0, [
                                          /* :: */[
                                            u,
                                            /* [] */0
                                          ],
                                          /* :: */[
                                            /* Binop */Block.__(2, [
                                                e[0],
                                                match$3[1],
                                                match$2[1]
                                              ]),
                                            /* [] */0
                                          ]
                                        ]),
                                      /* [] */0
                                    ]));
                  case 0 : 
                  case 1 : 
                  case 3 : 
                      return /* :: */[
                              c,
                              /* [] */0
                            ];
                  
                }
              }
            }
          } else {
            return /* :: */[
                    c,
                    /* [] */0
                  ];
          }
        }
      } else {
        return /* :: */[
                c,
                /* [] */0
              ];
      }
    }
  };
  var enableAsgProg = function (p) {
    return List.concat(List.map(enableAsgCom, p));
  };
  var FuncMap = $$Map.Make([$$String.compare]);
  var Invalid_input = Caml_exceptions.create("SS.SSFromBackEnd(Lang).Invalid_input");
  var strip = function (e) {
    if (e.tag === 1) {
      return e[0];
    } else {
      throw [
            Invalid_input,
            e
          ];
    }
  };
  var enableFuncCom = function (st, c) {
    switch (c.tag | 0) {
      case 0 : 
          var match = c[1];
          if (match) {
            var match$1 = match[0];
            if (match$1.tag === 3) {
              if (match[1]) {
                return /* :: */[
                        c,
                        /* [] */0
                      ];
              } else {
                try {
                  var ids = c[0];
                  var args = match$1[1];
                  var f = Curry._2(FuncMap[/* find */21], match$1[0], st[0]);
                  var zip = function (param, param$1) {
                    return List.map2((function (x, y) {
                                  return /* tuple */[
                                          x,
                                          y
                                        ];
                                }), param, param$1);
                  };
                  var match_000 = zip(f[/* outputs */1], ids);
                  var match_001 = zip(f[/* inputs */0], List.map(strip, args));
                  var outList = match_000;
                  var argList = match_001;
                  var p = f[/* body */2];
                  var substId = function (subsList, id) {
                    try {
                      return List.assoc(id, subsList);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        var body = id[0];
                        if (body === "i") {
                          return id;
                        } else {
                          return /* tuple */[
                                  "up" + body,
                                  id[1]
                                ];
                        }
                      } else {
                        throw exn;
                      }
                    }
                  };
                  var substExp = function (e) {
                    if (e.tag === 1) {
                      var id = e[0];
                      if (id[0] === "i" && Lang[/* supportsI */3]) {
                        return /* Var */Block.__(1, [id]);
                      } else {
                        return /* Var */Block.__(1, [substId(Pervasives.$at(outList, argList), id)]);
                      }
                    } else {
                      return e;
                    }
                  };
                  var substCom = function (c) {
                    if (c.tag) {
                      throw PL_functor.Invalid_command;
                    } else {
                      var match = c[0];
                      if (match) {
                        if (match[1]) {
                          throw PL_functor.Invalid_command;
                        } else {
                          var match$1 = c[1];
                          if (match$1) {
                            var match$2 = match$1[0];
                            var h = match[0];
                            switch (match$2.tag | 0) {
                              case 1 : 
                                  if (match$1[1]) {
                                    throw PL_functor.Invalid_command;
                                  } else {
                                    return /* Asg */Block.__(0, [
                                              /* :: */[
                                                substId(outList, h),
                                                /* [] */0
                                              ],
                                              /* :: */[
                                                substExp(/* Var */Block.__(1, [match$2[0]])),
                                                /* [] */0
                                              ]
                                            ]);
                                  }
                                  break;
                              case 2 : 
                                  if (match$1[1]) {
                                    throw PL_functor.Invalid_command;
                                  } else {
                                    return /* Asg */Block.__(0, [
                                              /* :: */[
                                                substId(outList, h),
                                                /* [] */0
                                              ],
                                              /* :: */[
                                                /* Binop */Block.__(2, [
                                                    match$2[0],
                                                    substExp(match$2[1]),
                                                    substExp(match$2[2])
                                                  ]),
                                                /* [] */0
                                              ]
                                            ]);
                                  }
                                  break;
                              case 0 : 
                              case 3 : 
                                  throw PL_functor.Invalid_command;
                              
                            }
                          } else {
                            throw PL_functor.Invalid_command;
                          }
                        }
                      } else {
                        throw PL_functor.Invalid_command;
                      }
                    }
                  };
                  return List.map(substCom, p);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return /* :: */[
                            c,
                            /* [] */0
                          ];
                  } else {
                    throw exn;
                  }
                }
              }
            } else {
              return /* :: */[
                      c,
                      /* [] */0
                    ];
            }
          } else {
            return /* :: */[
                    c,
                    /* [] */0
                  ];
          }
          break;
      case 1 : 
          var curStore = st[0];
          var macro = function (param) {
            return enableFuncCom(st, param);
          };
          var newBody = List.concat(List.map(macro, c[1]));
          st[0] = curStore;
          return /* :: */[
                  /* If */Block.__(1, [
                      c[0],
                      newBody
                    ]),
                  /* [] */0
                ];
      case 2 : 
          var f$1 = c[1];
          var curStore$1 = st[0];
          var macro$1 = function (param) {
            return enableFuncCom(st, param);
          };
          var newBody$1 = List.concat(List.map(macro$1, f$1[/* body */2]));
          var newFun_000 = /* inputs */f$1[/* inputs */0];
          var newFun_001 = /* outputs */f$1[/* outputs */1];
          var newFun = /* record */[
            newFun_000,
            newFun_001,
            /* body */newBody$1
          ];
          st[0] = Curry._3(FuncMap[/* add */3], c[0], newFun, curStore$1);
          return /* [] */0;
      case 3 : 
      case 4 : 
          return /* :: */[
                  c,
                  /* [] */0
                ];
      
    }
  };
  var enableFuncProg = function (p) {
    var st = [FuncMap[/* empty */0]];
    var macro = function (param) {
      return enableFuncCom(st, param);
    };
    return List.concat(List.map(macro, p));
  };
  var enableNestedFuncCom = function (c) {
    if (c.tag) {
      return /* :: */[
              c,
              /* [] */0
            ];
    } else {
      var match = c[0];
      if (match) {
        if (match[1]) {
          return /* :: */[
                  c,
                  /* [] */0
                ];
        } else {
          var match$1 = c[1];
          if (match$1) {
            var match$2 = match$1[0];
            if (match$2.tag === 3) {
              if (match$1[1]) {
                return /* :: */[
                        c,
                        /* [] */0
                      ];
              } else {
                var argList = List.map(expandExp, match$2[1]);
                var processArg = function (param, param$1) {
                  return /* tuple */[
                          Pervasives.$at(param[0], param$1[0]),
                          /* :: */[
                            param[1],
                            param$1[1]
                          ]
                        ];
                };
                var match$3 = List.fold_right(processArg, argList, /* tuple */[
                      /* [] */0,
                      /* [] */0
                    ]);
                return Pervasives.$at(match$3[0], /* :: */[
                            /* Asg */Block.__(0, [
                                /* :: */[
                                  match[0],
                                  /* [] */0
                                ],
                                /* :: */[
                                  /* FxnApp */Block.__(3, [
                                      match$2[0],
                                      match$3[1]
                                    ]),
                                  /* [] */0
                                ]
                              ]),
                            /* [] */0
                          ]);
              }
            } else {
              return /* :: */[
                      c,
                      /* [] */0
                    ];
            }
          } else {
            return /* :: */[
                    c,
                    /* [] */0
                  ];
          }
        }
      } else {
        return /* :: */[
                c,
                /* [] */0
              ];
      }
    }
  };
  var enableNestedFuncProg = function (p) {
    return List.concat(List.map(enableNestedFuncCom, p));
  };
  var preventShadowing = function (p) {
    var handleId = function (id) {
      var body = id[0];
      if (body.length >= 2 && $$String.sub(body, 0, 2) === "up") {
        return /* tuple */[
                "up" + body,
                id[1]
              ];
      } else {
        return id;
      }
    };
    var handleVar = function (e) {
      if (e.tag === 1) {
        return /* Var */Block.__(1, [handleId(e[0])]);
      } else {
        throw PL_functor.Invalid_expression;
      }
    };
    var handleCom = function (c) {
      if (c.tag) {
        throw PL_functor.Invalid_command;
      } else {
        var outList = c[0];
        var exit = 0;
        if (outList) {
          if (outList[1]) {
            exit = 1;
          } else {
            var match = c[1];
            if (match) {
              var match$1 = match[0];
              var h = outList[0];
              switch (match$1.tag | 0) {
                case 0 : 
                    throw PL_functor.Invalid_command;
                case 1 : 
                    if (match[1]) {
                      throw PL_functor.Invalid_command;
                    } else {
                      return /* Asg */Block.__(0, [
                                /* :: */[
                                  handleId(h),
                                  /* [] */0
                                ],
                                /* :: */[
                                  /* Var */Block.__(1, [handleId(match$1[0])]),
                                  /* [] */0
                                ]
                              ]);
                    }
                    break;
                case 2 : 
                    var match$2 = match$1[1];
                    if (match$2.tag === 1) {
                      var match$3 = match$1[2];
                      if (match$3.tag === 1) {
                        if (match[1]) {
                          throw PL_functor.Invalid_command;
                        } else {
                          return /* Asg */Block.__(0, [
                                    /* :: */[
                                      handleId(h),
                                      /* [] */0
                                    ],
                                    /* :: */[
                                      /* Binop */Block.__(2, [
                                          match$1[0],
                                          /* Var */Block.__(1, [handleId(match$2[0])]),
                                          /* Var */Block.__(1, [handleId(match$3[0])])
                                        ]),
                                      /* [] */0
                                    ]
                                  ]);
                        }
                      } else {
                        throw PL_functor.Invalid_command;
                      }
                    } else {
                      throw PL_functor.Invalid_command;
                    }
                    break;
                case 3 : 
                    exit = 1;
                    break;
                
              }
            } else {
              throw PL_functor.Invalid_command;
            }
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var match$4 = c[1];
          if (match$4) {
            var match$5 = match$4[0];
            if (match$5.tag === 3) {
              if (match$4[1]) {
                throw PL_functor.Invalid_command;
              } else {
                return /* Asg */Block.__(0, [
                          List.map(handleId, outList),
                          /* :: */[
                            /* FxnApp */Block.__(3, [
                                match$5[0],
                                List.map(handleVar, match$5[1])
                              ]),
                            /* [] */0
                          ]
                        ]);
              }
            } else {
              throw PL_functor.Invalid_command;
            }
          } else {
            throw PL_functor.Invalid_command;
          }
        }
        
      }
    };
    return List.map(handleCom, p);
  };
  var enableNestedIfCom = function (c) {
    if (c.tag === 1) {
      var match = expandExp(c[0]);
      return Pervasives.$at(match[0], /* :: */[
                  /* If */Block.__(1, [
                      match[1],
                      c[1]
                    ]),
                  /* [] */0
                ]);
    } else {
      return /* :: */[
              c,
              /* [] */0
            ];
    }
  };
  var enableNestedIfProg = function (p) {
    return List.concat(List.map(enableNestedIfCom, p));
  };
  var enableMUX = function (b, param) {
    var match_000 = PL_functor.strOfId(b);
    var match_001 = PL_functor.strOfId(param[0]);
    var match_002 = PL_functor.strOfId(param[1]);
    var lStr = match_001;
    return NANDparser.parseProg(NANDlexer.token, Lexing.from_string(lStr + (" := MUX(" + (match_000 + (", " + (lStr + (", " + (match_002 + ")"))))))));
  };
  var muxDefProg = NANDparser.parseProg(NANDlexer.token, Lexing.from_string(Lang[/* muxDefStr */5]));
  var restoreIProg = function (v, b) {
    var match_000 = PL_functor.strOfId(v);
    var match_001 = PL_functor.strOfId(b);
    return NANDparser.parseProg(NANDlexer.token, Lexing.from_string("tmp_0 := " + (match_000 + ("  tmp_1 := i i := " + (match_001 + "  i := tmp_i")))));
  };
  var enableIfCom = function (c) {
    switch (c.tag | 0) {
      case 1 : 
          var e = c[0];
          var p = preventShadowing(List.concat(List.map(enableIfCom, c[1])));
          var b = strip(e);
          var newB = freshVar(/* () */0);
          var s = PL_functor.strOfId(newB) + (" := " + PL_functor.strOfId(b));
          var p$1 = NANDparser.parseProg(NANDlexer.token, Lexing.from_string(s));
          var asg = List.concat(List.map(enableAsgCom, p$1));
          var newProg = Pervasives.$at(asg, List.concat(List.map((function (param) {
                          var b = newB;
                          var c = param;
                          if (c.tag) {
                            return /* :: */[
                                    c,
                                    /* [] */0
                                  ];
                          } else {
                            var match = c[0];
                            if (match) {
                              if (match[1]) {
                                return /* :: */[
                                        c,
                                        /* [] */0
                                      ];
                              } else {
                                var match$1 = c[1];
                                if (match$1) {
                                  if (match$1[1]) {
                                    return /* :: */[
                                            c,
                                            /* [] */0
                                          ];
                                  } else {
                                    var h = match[0];
                                    if (Caml_obj.caml_equal(h, /* tuple */[
                                            "i",
                                            /* Int */[0]
                                          ])) {
                                      return /* :: */[
                                              c,
                                              /* [] */0
                                            ];
                                    } else {
                                      var newH = freshVar(/* () */0);
                                      return Pervasives.$at(/* :: */[
                                                  /* Asg */Block.__(0, [
                                                      /* :: */[
                                                        newH,
                                                        /* [] */0
                                                      ],
                                                      /* :: */[
                                                        match$1[0],
                                                        /* [] */0
                                                      ]
                                                    ]),
                                                  /* [] */0
                                                ], enableMUX(b, /* tuple */[
                                                      h,
                                                      newH
                                                    ]));
                                    }
                                  }
                                } else {
                                  return /* :: */[
                                          c,
                                          /* [] */0
                                        ];
                                }
                              }
                            } else {
                              return /* :: */[
                                      c,
                                      /* [] */0
                                    ];
                            }
                          }
                        }), p)));
          var match;
          if (Lang[/* supportsAsg */4]) {
            var temp = freshVar(/* () */0);
            var match_000 = PL_functor.strOfId(temp);
            var match_001 = PL_functor.strOfId(b);
            match = /* tuple */[
              NANDparser.parseProg(NANDlexer.token, Lexing.from_string(match_000 + ":= i")),
              restoreIProg(temp, newB)
            ];
          } else {
            match = /* tuple */[
              /* [] */0,
              /* [] */0
            ];
          }
          return Pervasives.$at(match[0], Pervasives.$at(enableFuncProg(Pervasives.$at(muxDefProg, newProg)), match[1]));
      case 2 : 
          var f = c[1];
          return /* :: */[
                  /* FxnDef */Block.__(2, [
                      c[0],
                      /* record */[
                        /* inputs */f[/* inputs */0],
                        /* outputs */f[/* outputs */1],
                        /* body */List.concat(List.map(enableIfCom, f[/* body */2]))
                      ]
                    ]),
                  /* [] */0
                ];
      default:
        return /* :: */[
                c,
                /* [] */0
              ];
    }
  };
  var genPreLoop = function (preloop, finishedpreloop) {
    var s = PL_functor.strOfId(finishedpreloop) + " := one";
    var match_000 = /* FxnApp */Block.__(3, [
        "NOT",
        /* :: */[
          /* Var */Block.__(1, [finishedpreloop]),
          /* [] */0
        ]
      ]);
    var match_001 = NANDparser.parseProg(NANDlexer.token, Lexing.from_string(s));
    var body = Pervasives.$at(match_001, preloop);
    return /* :: */[
            /* If */Block.__(1, [
                match_000,
                body
              ]),
            /* [] */0
          ];
  };
  var genLoop = function (e, finishedpreloop, finishedloop, itemp, body) {
    var itempStr = PL_functor.strOfId(itemp);
    var recoveri = List.hd(NANDparser.parseProg(NANDlexer.token, Lexing.from_string("i := " + itempStr)));
    var innerif1_001 = enableWhileProg(Pervasives.$at(body, NANDparser.parseProg(NANDlexer.token, Lexing.from_string("loop := one " + (itempStr + " := i")))));
    var innerif1 = /* If */Block.__(1, [
        e,
        innerif1_001
      ]);
    var s = PL_functor.strOfId(finishedloop) + " := one loop := zero";
    var match_000 = /* FxnApp */Block.__(3, [
        "NOT",
        /* :: */[
          e,
          /* [] */0
        ]
      ]);
    var match_001 = NANDparser.parseProg(NANDlexer.token, Lexing.from_string(s));
    var innerif2_000 = match_000;
    var innerif2_001 = match_001;
    var innerif2 = /* If */Block.__(1, [
        innerif2_000,
        innerif2_001
      ]);
    var pred = /* Var */Block.__(1, [finishedpreloop]);
    return /* :: */[
            /* If */Block.__(1, [
                pred,
                /* :: */[
                  recoveri,
                  /* :: */[
                    innerif1,
                    /* :: */[
                      innerif2,
                      /* [] */0
                    ]
                  ]
                ]
              ]),
            /* [] */0
          ];
  };
  var genPostLoop = function (finishedloop, postloop) {
    return /* :: */[
            /* If */Block.__(1, [
                /* Var */Block.__(1, [finishedloop]),
                enableWhileProg(postloop)
              ]),
            /* [] */0
          ];
  };
  var expandWhile = function (e, preloop, body, postloop) {
    var match_000 = freshVar(/* () */0);
    var match_001 = freshVar(/* () */0);
    var match_002 = freshVar(/* () */0);
    var finishedloop = match_001;
    var finishedpreloop = match_000;
    var match_000$1 = genPreLoop(preloop, finishedpreloop);
    var match_001$1 = genLoop(e, finishedpreloop, finishedloop, match_002, body);
    var match_002$1 = genPostLoop(finishedloop, postloop);
    return Pervasives.$at(match_000$1, Pervasives.$at(match_001$1, match_002$1));
  };
  var enableWhileProg = function (p) {
    if (Lang[/* supportsI */3]) {
      return p;
    } else {
      var left = [/* [] */0];
      var fxndefs = [/* [] */0];
      var enableWhileProgHelp = function (_p) {
        while(true) {
          var p = _p;
          if (p) {
            var right = p[1];
            var c = p[0];
            var exit = 0;
            switch (c.tag | 0) {
              case 1 : 
                  left[0] = Pervasives.$at(left[0], /* :: */[
                        /* If */Block.__(1, [
                            c[0],
                            enableWhileProg(c[1])
                          ]),
                        /* [] */0
                      ]);
                  _p = right;
                  continue ;
                  case 2 : 
                  var f = c[1];
                  var newDef_000 = c[0];
                  var newDef_001 = /* record */[
                    /* inputs */f[/* inputs */0],
                    /* outputs */f[/* outputs */1],
                    /* body */enableWhileProg(f[/* body */2])
                  ];
                  var newDef = /* FxnDef */Block.__(2, [
                      newDef_000,
                      newDef_001
                    ]);
                  fxndefs[0] = /* :: */[
                    newDef,
                    fxndefs[0]
                  ];
                  _p = right;
                  continue ;
                  case 3 : 
                  left[0] = expandWhile(c[0], left[0], enableWhileProg(c[1]), right);
                  return /* () */0;
              case 0 : 
              case 4 : 
                  exit = 1;
                  break;
              
            }
            if (exit === 1) {
              left[0] = Pervasives.$at(left[0], /* :: */[
                    c,
                    /* [] */0
                  ]);
              _p = right;
              continue ;
              
            }
            
          } else {
            return /* () */0;
          }
        };
      };
      enableWhileProgHelp(p);
      return Pervasives.$at(List.rev(fxndefs[0]), left[0]);
    }
  };
  var macroList_001 = /* :: */[
    enableAsgProg,
    /* :: */[
      enableNestedFuncProg,
      /* :: */[
        enableNestedIfProg,
        /* [] */0
      ]
    ]
  ];
  var macroList = /* :: */[
    unzipProg,
    macroList_001
  ];
  var otherMacros = List.fold_left((function (acc, f, p) {
          return Curry._1(f, Curry._1(acc, p));
        }), (function (x) {
          return x;
        }), List.map(enableNestedApp, macroList));
  var addSS = function (p) {
    var p$1 = Curry._1(otherMacros, addStdLib(p));
    var p$prime = List.concat(List.map(enableIfCom, p$1));
    return Curry._1(otherMacros, enableFuncProg(p$prime));
  };
  return /* module */[/* addSS */addSS];
}

exports.parseStr        = parseStr;
exports.genLine         = genLine;
exports.freshVar        = freshVar;
exports.isValue         = isValue;
exports.mapToProg       = mapToProg;
exports.enableNestedApp = enableNestedApp;
exports.SSFromBackEnd   = SSFromBackEnd;
/* NANDlexer Not a pure module */
