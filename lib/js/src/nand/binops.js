// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function makeReturnBit(f, l, r) {
  if (Curry._2(f, l, r)) {
    return 1;
  } else {
    return 0;
  }
}

function nand(x, y) {
  if (Caml_int32.imul(x, y) > 0) {
    return 0;
  } else {
    return 1;
  }
}

var binopList_000 = /* tuple */[
  "NAND",
  nand
];

var binopList_001 = /* :: */[
  /* tuple */[
    "+",
    (function (prim, prim$1) {
        return prim + prim$1 | 0;
      })
  ],
  /* :: */[
    /* tuple */[
      "-",
      (function (prim, prim$1) {
          return prim - prim$1 | 0;
        })
    ],
    /* :: */[
      /* tuple */[
        "/",
        Caml_int32.div
      ],
      /* :: */[
        /* tuple */[
          "==",
          (function (param, param$1) {
              return makeReturnBit(Caml_obj.caml_equal, param, param$1);
            })
        ],
        /* :: */[
          /* tuple */[
            "*",
            Caml_int32.imul
          ],
          /* :: */[
            /* tuple */[
              "<",
              (function (param, param$1) {
                  return makeReturnBit(Caml_obj.caml_lessthan, param, param$1);
                })
            ],
            /* :: */[
              /* tuple */[
                ">",
                (function (param, param$1) {
                    return makeReturnBit(Caml_obj.caml_greaterthan, param, param$1);
                  })
              ],
              /* :: */[
                /* tuple */[
                  "%",
                  Caml_int32.mod_
                ],
                /* :: */[
                  /* tuple */[
                    "&&",
                    (function (prim, prim$1) {
                        return prim & prim$1;
                      })
                  ],
                  /* :: */[
                    /* tuple */[
                      "^",
                      (function (prim, prim$1) {
                          return prim ^ prim$1;
                        })
                    ],
                    /* :: */[
                      /* tuple */[
                        ">>",
                        (function (prim, prim$1) {
                            return (prim >>> prim$1) | 0;
                          })
                      ],
                      /* :: */[
                        /* tuple */[
                          "<<",
                          (function (prim, prim$1) {
                              return (prim << prim$1);
                            })
                        ],
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var binopList = /* :: */[
  binopList_000,
  binopList_001
];

function binopOfStr(b) {
  return List.assoc(b, binopList);
}

exports.makeReturnBit = makeReturnBit;
exports.nand          = nand;
exports.binopList     = binopList;
exports.binopOfStr    = binopOfStr;
/* No side effect */
