// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map                   = require("bs-platform/lib/js/map.js");
var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Binops                  = require("./binops.js");
var Printf                  = require("bs-platform/lib/js/printf.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function strOfIndex(i) {
  if (i) {
    return "_" + Pervasives.string_of_int(i[0]);
  } else {
    return "_i";
  }
}

function strOfId(id) {
  var body = id[0];
  if (body === "loop" || body === "i") {
    return body;
  } else {
    return body + strOfIndex(id[1]);
  }
}

var Invalid_command = Caml_exceptions.create("PL_functor.Invalid_command");

var Invalid_expression = Caml_exceptions.create("PL_functor.Invalid_expression");

function mapOverCom(f, c) {
  var exit = 0;
  if (c.tag) {
    exit = 1;
  } else {
    var match = c[0];
    if (match) {
      if (match[1]) {
        exit = 1;
      } else {
        var match$1 = c[1];
        if (match$1) {
          var match$2 = match$1[0];
          var h = match[0];
          switch (match$2.tag | 0) {
            case 1 : 
                if (match$1[1]) {
                  exit = 1;
                } else {
                  return Curry._4(f, /* None */0, h, /* Var */Block.__(1, [match$2[0]]), /* None */0);
                }
                break;
            case 2 : 
                if (match$1[1]) {
                  exit = 1;
                } else {
                  return Curry._4(f, /* Some */[match$2[0]], h, match$2[1], /* Some */[match$2[2]]);
                }
                break;
            case 0 : 
            case 3 : 
                exit = 1;
                break;
            
          }
        } else {
          exit = 1;
        }
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    Printf.printf(/* Format */[
          /* String_literal */Block.__(11, [
              "DEBUG: mapoverCom",
              /* End_of_format */0
            ]),
          "DEBUG: mapoverCom"
        ]);
    throw Invalid_command;
  }
  
}

function strOfExp(e) {
  switch (e.tag | 0) {
    case 0 : 
        if (e[0]) {
          return "one";
        } else {
          return "zero";
        }
    case 1 : 
        return strOfId(e[0]);
    case 2 : 
    case 3 : 
        Printf.printf(/* Format */[
              /* String_literal */Block.__(11, [
                  "DEBUG: strofexp\n",
                  /* End_of_format */0
                ]),
              "DEBUG: strofexp\n"
            ]);
        throw Invalid_command;
    
  }
}

function f(b, h, l, r) {
  if (b) {
    if (r) {
      return strOfId(h) + (" := " + (strOfExp(l) + (" " + (b[0] + (" " + strOfExp(r[0]))))));
    } else {
      Printf.printf(/* Format */[
            /* String_literal */Block.__(11, [
                "DEBUG: strofcom\n",
                /* End_of_format */0
              ]),
            "DEBUG: strofcom\n"
          ]);
      throw Invalid_command;
    }
  } else if (r) {
    Printf.printf(/* Format */[
          /* String_literal */Block.__(11, [
              "DEBUG: strofcom\n",
              /* End_of_format */0
            ]),
          "DEBUG: strofcom\n"
        ]);
    throw Invalid_command;
  } else {
    return strOfId(h) + (" := " + strOfExp(l));
  }
}

function strOfCom(param) {
  return mapOverCom(f, param);
}

function strOfProg(p) {
  return $$String.concat("\n", List.map(strOfCom, p));
}

function printProg(p, _) {
  Printf.printf(/* Format */[
        /* String_literal */Block.__(11, [
            "printProg has been called!\n",
            /* End_of_format */0
          ]),
        "printProg has been called!\n"
      ]);
  return Curry._1(Printf.printf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%s"
                ]), strOfProg(p));
}

var VarMap = $$Map.Make([$$String.compare]);

function safeFind(str, st) {
  try {
    return Curry._2(VarMap[/* find */21], str, st);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return 0;
    } else {
      throw exn;
    }
  }
}

function varFind(id, st) {
  return safeFind(strOfId(id), st);
}

var Invalid_char = Caml_exceptions.create("PL_functor.Invalid_char");

var Invalid_bit = Caml_exceptions.create("PL_functor.Invalid_bit");

var Invalid_binop = Caml_exceptions.create("PL_functor.Invalid_binop");

var printLines = [/* true */1];

function PLFromBackEnd(Lang) {
  var bitOfChar = function (c) {
    if (c !== 48) {
      if (c !== 49) {
        throw [
              Invalid_char,
              c
            ];
      } else {
        return 1;
      }
    } else {
      return 0;
    }
  };
  var storeOfString = function (xVals) {
    var s = [VarMap[/* empty */0]];
    var add = function (i, c) {
      var id = "x_" + Pervasives.string_of_int(i);
      s[0] = Curry._3(VarMap[/* add */3], id, bitOfChar(c), s[0]);
      return /* () */0;
    };
    $$String.iteri(add, xVals);
    return s[0];
  };
  var updateProgData = function (pData, st) {
    if (!pData[/* i */3]) {
      pData[/* r */1] = pData[/* r */1] + 1 | 0;
      pData[/* inc */4] = 1;
    }
    if (pData[/* i */3] === pData[/* r */1]) {
      pData[/* inc */4] = -1;
    }
    pData[/* i */3] = pData[/* i */3] + pData[/* inc */4] | 0;
    pData[/* pc */0] = pData[/* pc */0] + 1 | 0;
    st[0] = Curry._3(VarMap[/* add */3], "i", pData[/* i */3], st[0]);
    return /* () */0;
  };
  var incM = function (pData, c, st) {
    var extractIndexVal = function (id) {
      var ind = id[1];
      if (id[0] === "y") {
        if (ind) {
          return ind[0] + 1 | 0;
        } else {
          return safeFind("i", st) + 1 | 0;
        }
      } else {
        return -1;
      }
    };
    if (c.tag) {
      return /* () */0;
    } else {
      var match = c[0];
      if (match && !match[1]) {
        pData[/* m */2] = Pervasives.max(pData[/* m */2], extractIndexVal(match[0]));
        return /* () */0;
      } else {
        return /* () */0;
      }
    }
  };
  var extractId = function (st, x) {
    var body = x[0];
    switch (body) {
      case "i" : 
          if (Lang[/* supportsI */3]) {
            return "i";
          } else {
            throw Invalid_expression;
          }
          break;
      case "loop" : 
          if (Lang[/* supportsLoop */2]) {
            return "loop";
          } else {
            throw Invalid_expression;
          }
          break;
      default:
        return body + ("_" + Pervasives.string_of_int(Curry._2(Lang[/* evalIndex */0], st, x[1])));
    }
  };
  var evalExp = function (pData, st, e) {
    if (e.tag === 1) {
      var x = e[0];
      if (x[0] === "validx") {
        if (Lang[/* supportsLoop */2]) {
          var i = Curry._2(Lang[/* evalIndex */0], st[0], x[1]);
          return /* tuple */[
                  "validx_" + Pervasives.string_of_int(i),
                  i < pData[/* n */5] ? 1 : 0
                ];
        } else {
          throw Invalid_expression;
        }
      } else {
        var id = extractId(st[0], x);
        return /* tuple */[
                id,
                safeFind(id, st[0])
              ];
      }
    } else {
      throw Invalid_expression;
    }
  };
  var checkId = function (id) {
    switch (id[0]) {
      case "i" : 
          if (!Lang[/* supportsI */3]) {
            Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "Exception raised here\n",
                      /* End_of_format */0
                    ]),
                  "Exception raised here\n"
                ]);
          }
          throw Invalid_expression;
      case "validx" : 
          throw Invalid_expression;
      default:
        return /* () */0;
    }
  };
  var execute = function (p, s) {
    var pData = /* record */[
      /* pc */0,
      /* r */0,
      /* m */0,
      /* i */0,
      /* inc */1,
      /* n */s.length
    ];
    var st = [storeOfString(s)];
    var evalLoop = function (_param) {
      while(true) {
        List.iter((function (param) {
                var pData$1 = pData;
                var st$1 = st;
                var c = param;
                switch (c.tag | 0) {
                  case 0 : 
                      var match = c[0];
                      if (match) {
                        if (match[1]) {
                          throw Invalid_command;
                        } else {
                          var match$1 = c[1];
                          if (match$1) {
                            var match$2 = match$1[0];
                            var id = match[0];
                            switch (match$2.tag | 0) {
                              case 1 : 
                                  if (match$1[1]) {
                                    throw Invalid_command;
                                  } else if (Lang[/* supportsAsg */4]) {
                                    var comStr = strOfCom(c);
                                    var match$3 = evalExp(pData$1, st$1, /* Var */Block.__(1, [match$2[0]]));
                                    var resVal = match$3[1];
                                    var resId = extractId(st$1[0], id);
                                    st$1[0] = Curry._3(VarMap[/* add */3], resId, resVal, st$1[0]);
                                    Curry._5(Printf.printf(/* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "Executing command \"",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          "\", ",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  " has value ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          ", ",
                                                                          /* String */Block.__(2, [
                                                                              /* No_padding */0,
                                                                              /* String_literal */Block.__(11, [
                                                                                  " assigned value ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Char_literal */Block.__(12, [
                                                                                          /* "\n" */10,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "Executing command \"%s\", %s has value %s, %s assigned value %s\n"
                                            ]), comStr, match$3[0], Pervasives.string_of_int(resVal), resId, Pervasives.string_of_int(resVal));
                                    return incM(pData$1, c, st$1[0]);
                                  } else {
                                    throw Invalid_command;
                                  }
                                  break;
                              case 2 : 
                                  if (match$1[1]) {
                                    throw Invalid_command;
                                  } else {
                                    var b = match$2[0];
                                    checkId(id);
                                    if (Curry._1(Lang[/* supportsBinop */1], b)) {
                                      var comStr$1 = strOfCom(c);
                                      var match_000 = evalExp(pData$1, st$1, match$2[1]);
                                      var match_001 = evalExp(pData$1, st$1, match$2[2]);
                                      var match$4 = match_001;
                                      var rhsVal = match$4[1];
                                      var match$5 = match_000;
                                      var lhsVal = match$5[1];
                                      var binop = Binops.binopOfStr(b);
                                      var match_000$1 = Curry._2(binop, lhsVal, rhsVal);
                                      var match_001$1 = extractId(st$1[0], id);
                                      var resId$1 = match_001$1;
                                      var resVal$1 = match_000$1;
                                      st$1[0] = Curry._3(VarMap[/* add */3], resId$1, resVal$1, st$1[0]);
                                      if (printLines[0]) {
                                        Curry._7(Printf.printf(/* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "Executing commmand \"",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* String_literal */Block.__(11, [
                                                              "\", ",
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* String_literal */Block.__(11, [
                                                                      " has value ",
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* String_literal */Block.__(11, [
                                                                              ", ",
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* String_literal */Block.__(11, [
                                                                                      " has value ",
                                                                                      /* String */Block.__(2, [
                                                                                          /* No_padding */0,
                                                                                          /* String_literal */Block.__(11, [
                                                                                              ", ",
                                                                                              /* String */Block.__(2, [
                                                                                                  /* No_padding */0,
                                                                                                  /* String_literal */Block.__(11, [
                                                                                                      " assigned value ",
                                                                                                      /* String */Block.__(2, [
                                                                                                          /* No_padding */0,
                                                                                                          /* Char_literal */Block.__(12, [
                                                                                                              /* "\n" */10,
                                                                                                              /* End_of_format */0
                                                                                                            ])
                                                                                                        ])
                                                                                                    ])
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ]),
                                                  "Executing commmand \"%s\", %s has value %s, %s has value %s, %s assigned value %s\n"
                                                ]), comStr$1, match$5[0], Pervasives.string_of_int(lhsVal), match$4[0], Pervasives.string_of_int(rhsVal), resId$1, Pervasives.string_of_int(resVal$1));
                                      }
                                      return incM(pData$1, c, st$1[0]);
                                    } else {
                                      throw [
                                            Invalid_binop,
                                            b
                                          ];
                                    }
                                  }
                                  break;
                              case 0 : 
                              case 3 : 
                                  throw Invalid_command;
                              
                            }
                          } else {
                            throw Invalid_command;
                          }
                        }
                      } else {
                        throw Invalid_command;
                      }
                      break;
                  case 4 : 
                      var match$6 = evalExp(pData$1, st$1, /* Var */Block.__(1, [c[0]]));
                      return Curry._2(Printf.printf(/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "The value of ",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */Block.__(11, [
                                                  " is: ",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Char_literal */Block.__(12, [
                                                          /* "\n" */10,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "The value of %s is: %s\n"
                                    ]), match$6[0], Pervasives.string_of_int(match$6[1]));
                  default:
                    throw Invalid_command;
                }
              }), p);
        updateProgData(pData, st);
        if (Lang[/* supportsLoop */2] && safeFind("loop", st[0]) === 1) {
          Printf.printf(/* Format */[
                /* String_literal */Block.__(11, [
                    "Entering new iteration\n",
                    /* End_of_format */0
                  ]),
                "Entering new iteration\n"
              ]);
          _param = /* () */0;
          continue ;
          
        } else {
          return 0;
        }
      };
    };
    evalLoop(/* () */0);
    var s$1 = st[0];
    var m = pData[/* m */2];
    var helpEvalStore = function (s, i) {
      var id_001 = /* Int */[i];
      var id = /* tuple */[
        "y",
        id_001
      ];
      if (i < m) {
        return Pervasives.string_of_int(safeFind(strOfId(id), s)) + helpEvalStore(s, i + 1 | 0);
      } else {
        return "";
      }
    };
    return helpEvalStore(s$1, 0);
  };
  return /* module */[/* execute */execute];
}

exports.strOfIndex         = strOfIndex;
exports.strOfId            = strOfId;
exports.Invalid_command    = Invalid_command;
exports.Invalid_expression = Invalid_expression;
exports.mapOverCom         = mapOverCom;
exports.strOfExp           = strOfExp;
exports.strOfCom           = strOfCom;
exports.strOfProg          = strOfProg;
exports.printProg          = printProg;
exports.VarMap             = VarMap;
exports.safeFind           = safeFind;
exports.varFind            = varFind;
exports.Invalid_char       = Invalid_char;
exports.Invalid_bit        = Invalid_bit;
exports.Invalid_binop      = Invalid_binop;
exports.printLines         = printLines;
exports.PLFromBackEnd      = PLFromBackEnd;
/* VarMap Not a pure module */
